import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.*;

public class JsonFlattenerProgram {

    private static final ObjectMapper mapper = new ObjectMapper();

    public static void main(String[] args) throws Exception {
        String json = "{\"users\": [{\"id\": 101, \"name\": \"Alice\", \"details\": {\"type\": \"admin\"}, \"phoneNumber\": [\"123123123\", \"789789789\"], \"roles\": [{\"roleId\": 1, \"roleName\": \"manager\"}, {\"roleId\": 2, \"roleName\": \"developer\"}]} , {\"id\": 102, \"name\": \"Bob\", \"details\": {\"type\": \"user\"}, \"roles\": [{\"roleId\": 3, \"roleName\": \"tester\"}]}]}";

        JsonNode root = mapper.readTree(json);

        // Define ignoreFields (dot notation)
        Map<String, List<String>> ignoreFields = new HashMap<>();
        ignoreFields.put("users", List.of("name"));

        // Define uniqueKeys with array names only (dot notation)
        Map<String, List<String>> uniqueKeys = new HashMap<>();
        uniqueKeys.put("users", List.of("id", "details.type", "roles.roleId"));

        // Flatten JSON
        Map<String, Object> flattened = new LinkedHashMap<>();
        flattenJson("", root, flattened, normaliseField(ignoreFields), normaliseField(uniqueKeys));

        // Print result
        flattened.forEach((k, v) -> System.out.println(k + " = " + v));
    }

    public static void flattenJson(String currentPath, JsonNode node,
                                   Map<String, Object> result,
                                   Map<String, List<String>> ignoreFields,
                                   Map<String, List<String>> uniqueKeys) {

        if (node == null || node.isNull()) {
            result.put(currentPath, null);
            return;
        }

        String normalizedParent = normalizePath(currentPath);

        if (node.isObject()) {
            List<String> fieldsToIgnore = ignoreFields.getOrDefault(normalizedParent, Collections.emptyList());

            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                String fieldName = field.getKey();

                if (fieldsToIgnore.contains(fieldName)) continue;

                String newPath = currentPath.isEmpty() ? fieldName : currentPath + "/" + fieldName;
                flattenJson(newPath, field.getValue(), result, ignoreFields, uniqueKeys);
            }

        } else if (node.isArray()) {
            String arrayName = getLastPathSegment(normalizedParent);
            List<String> keyFields = uniqueKeys.get(arrayName);

            for (int i = 0; i < node.size(); i++) {
                JsonNode item = node.get(i);
                String identifier;

                if (keyFields != null) {
                    List<String> keySegments = new ArrayList<>();
                    for (String keyField : keyFields) {
                        List<String> values = getValueListAtPath(item, keyField.replace(".", "/"));
                        if (values.isEmpty()) {
                            keySegments.add(keyField + "=null");
                        } else {
                            for (String val : values) {
                                keySegments.add(keyField + "=" + val);
                            }
                        }
                    }
                    identifier = "[" + String.join("|", keySegments) + "]";
                } else {
                    identifier = "[" + i + "]";
                }

                String newPath = currentPath + identifier;
                flattenJson(newPath, item, result, ignoreFields, uniqueKeys);
            }

        } else {
            result.put(currentPath, node.asText());
        }
    }

    // Utility: Normalize path (remove array indices, convert . to /)
    private static String normalizePath(String path) {
        return path.replaceAll("\\[[^\\]]*\\]", "").replace(".", "/");
    }

    // Utility: Get last segment of path
    private static String getLastPathSegment(String path) {
        if (path == null || path.isEmpty()) return "";
        String[] parts = path.split("/");
        return parts[parts.length - 1].replaceAll("\\[.*\\]", "");
    }

    // NEW: Get list of all matching values at the given nested path
    private static List<String> getValueListAtPath(JsonNode node, String path) {
        String[] parts = path.split("/");
        List<String> results = new ArrayList<>();
        collectValues(node, parts, 0, results);
        return results;
    }

    private static void collectValues(JsonNode node, String[] parts, int index, List<String> results) {
        if (node == null || node.isNull()) return;

        if (index == parts.length) {
            if (node.isValueNode()) {
                results.add(node.asText());
            }
            return;
        }

        String part = parts[index];

        if (node.isArray()) {
            for (JsonNode item : node) {
                collectValues(item, parts, index, results);
            }
        } else if (node.has(part)) {
            collectValues(node.get(part), parts, index + 1, results);
        }
    }

    // Convert dot-path maps to normalized path maps
    private static Map<String, List<String>> normaliseField(Map<String, List<String>> fieldToNormalise) {
        Map<String, List<String>> normalisedField = new HashMap<>();
        for (Map.Entry<String, List<String>> entry : fieldToNormalise.entrySet()) {
            String normalizedKey = entry.getKey().replace(".", "/");
            List<String> normalizedValue = entry.getValue().stream()
                    .map(s -> s.replace(".", "/"))
                    .toList();
            normalisedField.put(normalizedKey, normalizedValue);
        }
        return normalisedField;
    }
}
