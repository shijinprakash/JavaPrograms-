import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.util.*;

public class JsonFlattenerProgram {

    private static final ObjectMapper mapper = new ObjectMapper();

    public static void main(String[] args) throws Exception {
        // Step 1: Load JSON string
        String json = "{ \"user\": [ { \"name\": { \"firstName\": \"Alice\", \"middleName\": \"Marie\", \"lastName\": \"Johnson\", \"title\": \"Ms.\" }, \"phone\": { \"landLine\": \"+1-555-101010\", \"mobile\": [ { \"mobileNumber\": \"+1-555-202020\", \"details\": { \"type\": \"personal\", \"provider\": \"Verizon\", \"countryCode\": \"+1\", \"activatedOn\": \"2023-05-01\" } }, { \"mobileNumber\": \"+1-555-303030\", \"details\": { \"type\": \"office\", \"provider\": \"AT&T\", \"countryCode\": \"+1\", \"activatedOn\": \"2022-11-15\" } } ] }, \"email\": { \"emailIds\": [ { \"idType\": \"personal\", \"emailId\": \"alice.johnson@example.com\", \"usedIn\": { \"personal\": \"yes\", \"official\": \"no\", \"marketing\": \"yes\" }, \"verified\": true, \"addedOn\": \"2023-01-10\" }, { \"idType\": \"office\", \"emailId\": \"alice.j@company.com\", \"usedIn\": { \"personal\": \"no\", \"official\": \"yes\", \"marketing\": \"no\" }, \"verified\": true, \"addedOn\": \"2022-08-23\" } ] } }, { \"name\": { \"firstName\": \"Robert\", \"middleName\": \"Lee\", \"lastName\": \"Smith\", \"title\": \"Dr.\" }, \"phone\": { \"landLine\": \"+44-20-7946-0000\", \"mobile\": [ { \"mobileNumber\": \"+44-7700-900123\", \"details\": { \"type\": \"personal\", \"provider\": \"O2\", \"countryCode\": \"+44\", \"activatedOn\": \"2021-07-12\" } }, { \"mobileNumber\": \"+44-7700-900456\", \"details\": { \"type\": \"office\", \"provider\": \"Vodafone\", \"countryCode\": \"+44\", \"activatedOn\": \"2020-04-19\" } }, { \"mobileNumber\": \"+44-7700-900789\", \"details\": { \"type\": \"emergency\", \"provider\": \"EE\", \"countryCode\": \"+44\", \"activatedOn\": \"2019-12-01\" } } ] }, \"email\": { \"emailIds\": [ { \"idType\": \"personal\", \"emailId\": \"robert.smith@hotmail.com\", \"usedIn\": { \"personal\": \"yes\", \"official\": \"no\", \"marketing\": \"yes\" }, \"verified\": false, \"addedOn\": \"2021-02-10\" }, { \"idType\": \"office\", \"emailId\": \"robert.s@university.edu\", \"usedIn\": { \"personal\": \"no\", \"official\": \"yes\", \"marketing\": \"no\" }, \"verified\": true, \"addedOn\": \"2020-09-15\" }, { \"idType\": \"alternate\", \"emailId\": \"r.smith@altmail.com\", \"usedIn\": { \"personal\": \"yes\", \"official\": \"no\", \"marketing\": \"no\" }, \"verified\": false, \"addedOn\": \"2023-12-05\" } ] } } ] }";

        JsonNode root = mapper.readTree(json);

        // Step 2: Define ignoreFields with normalized full path to parent object
        Map<String, List<String>> ignoreFields = new HashMap<>();
        ignoreFields.put("user/name", List.of("title"));
        ignoreFields.put("user/phone", List.of("landLine"));

        // Step 3: Define uniqueKeys with normalized full path to parent array
        Map<String, List<String>> uniqueKeys = new HashMap<>();
        uniqueKeys.put("user/phone/mobile", List.of("mobileNumber", "details/type"));
        uniqueKeys.put("user/email/emailIds", List.of("emailId"));

        // Step 4: Flatten
        Map<String, Object> flattened = new LinkedHashMap<>();
        flattenJson("", root, flattened, ignoreFields, uniqueKeys);

        // Step 5: Print
        flattened.forEach((k, v) -> System.out.println(k + " = " + v));
    }

    public static void flattenJson(String currentPath, JsonNode node,
                                   Map<String, Object> result,
                                   Map<String, List<String>> ignoreFields,
                                   Map<String, List<String>> uniqueKeys) {

        if (node == null || node.isNull()) {
            result.put(currentPath, null);
            return;
        }

        // Normalized path for ignoreFields (slash-separated)
        String normalizedParent = normalizePath(currentPath, "/");

        if (node.isObject()) {
            List<String> fieldsToIgnore = ignoreFields.getOrDefault(normalizedParent, Collections.emptyList());

            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                String fieldName = field.getKey();
                if (fieldsToIgnore.contains(fieldName)) {
                    continue;
                }

                String newPath = currentPath.isEmpty() ? fieldName : currentPath + "/" + fieldName; // Change dot to slash
                flattenJson(newPath, field.getValue(), result, ignoreFields, uniqueKeys);
            }

        } else if (node.isArray()) {
            List<String> keyFields = uniqueKeys.get(normalizedParent);

            for (int i = 0; i < node.size(); i++) {
                JsonNode item = node.get(i);
                String identifier;

                if (keyFields != null) {
                    List<String> keyValues = new ArrayList<>();
                    for (String keyField : keyFields) {
                        JsonNode keyNode = getValueAtPath(item, keyField);
                        String keyVal = (keyNode != null && !keyNode.isNull()) ? keyNode.asText() : "null";
                        keyValues.add(keyField + ":" + keyVal);
                    }
                    identifier = "[" + String.join(",", keyValues) + "]";
                } else {
                    identifier = "[" + i + "]";
                }

                String newPath = currentPath + identifier;
                flattenJson(newPath, item, result, ignoreFields, uniqueKeys);
            }

        } else {
            result.put(currentPath, node.asText());
        }
    }

    // Normalize the path to a slash-separated path
    private static String normalizePath(String path, String separator) {
        return path.replaceAll("\\[[^\\]]*\\]", "").replace(".", separator);
    }

    // Get the value at a dot-separated nested path
    private static JsonNode getValueAtPath(JsonNode node, String path) {
        String[] parts = path.split("/");
        JsonNode current = node;
        for (String part : parts) {
            if (current != null && current.has(part)) {
                current = current.get(part);
            } else {
                return null;
            }
        }
        return current;
    }

    private static String getLastPathSegment(String path) {
        if (path == null || path.isEmpty()) return "";
        String[] parts = path.split("/");
        return parts[parts.length - 1].replaceAll("\\[.*\\]", "");
    }
}
