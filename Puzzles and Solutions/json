import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.util.*;

public class JsonFlattener {

    private static final ObjectMapper mapper = new ObjectMapper();

    public static void main(String[] args) throws Exception {
        // Load main JSON input
        JsonNode inputJson = mapper.readTree(new File("input.json"));

        // Load config (ignoreFields + uniqueKeys)
        JsonNode config = mapper.readTree(new File("config.json"));
        Set<String> ignoreFields = new HashSet<>();
        if (config.has("ignoreFields") && config.get("ignoreFields").isArray()) {
            for (JsonNode field : config.get("ignoreFields")) {
                ignoreFields.add(field.asText());
            }
        }

        Map<String, List<String>> uniqueKeys = new HashMap<>();
        if (config.has("uniqueKeys")) {
            JsonNode keysNode = config.get("uniqueKeys");
            for (Iterator<String> it = keysNode.fieldNames(); it.hasNext(); ) {
                String arrayName = it.next();
                JsonNode keysArray = keysNode.get(arrayName);
                List<String> keys = new ArrayList<>();
                for (JsonNode k : keysArray) keys.add(k.asText());
                uniqueKeys.put(arrayName, keys);
            }
        }

        Map<String, Object> flattened = new LinkedHashMap<>();
        flatten("", inputJson, flattened, ignoreFields, uniqueKeys);
        String result = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(flattened);
        System.out.println(result);
    }

    private static void flatten(String prefix, JsonNode node,
                                Map<String, Object> out,
                                Set<String> ignoreFields,
                                Map<String, List<String>> uniqueKeys) {

        if (node == null || node.isNull()) {
            out.put(prefix, null);
            return;
        }

        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                String key = field.getKey();

                if (ignoreFields.contains(key)) {
                    continue; // Skip ignored fields
                }

                String newPrefix = prefix.isEmpty() ? key : prefix + "." + key;
                flatten(newPrefix, field.getValue(), out, ignoreFields, uniqueKeys);
            }

        } else if (node.isArray()) {
            for (int i = 0; i < node.size(); i++) {
                JsonNode item = node.get(i);
                String baseName = getBaseName(prefix);
                String arrayIndex;

                // Try to find unique keys
                if (uniqueKeys.containsKey(baseName)) {
                    List<String> keys = uniqueKeys.get(baseName);
                    List<String> keyParts = new ArrayList<>();
                    for (String k : keys) {
                        JsonNode keyNode = item.get(k);
                        if (keyNode != null && !keyNode.isNull()) {
                            keyParts.add(k + ":" + keyNode.asText());
                        } else {
                            keyParts.add(k + ":null");
                        }
                    }
                    arrayIndex = "[" + String.join(",", keyParts) + "]";
                } else {
                    arrayIndex = "[" + i + "]";
                }

                String newPrefix = prefix + arrayIndex;
                flatten(newPrefix, item, out, ignoreFields, uniqueKeys);
            }
        } else {
            out.put(prefix, node.isValueNode() ? node.asText() : node.toString());
        }
    }

    private static String getBaseName(String path) {
        if (path == null || path.isEmpty()) return "";
        String[] parts = path.split("\\.");
        return parts[parts.length - 1].replaceAll("\\[.*\\]", "");
    }
}
